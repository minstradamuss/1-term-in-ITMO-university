#########################
# author: minstradamuss #
#   Loskutova Mariia    #
#########################

import matplotlib.pyplot as plt
import numpy as np
import math

print ("Лабораторная работа №2")
print ("Тема: Формула Тейлора")
print ("Часть 2. Численный метод.")
print ("Выберите номер задания, который вы хотите посмотреть (введите номер задания без пробелов).")
print ("Если вы хотите закончить просмотр, введите 0.")

s = ""

while s != "0":

    s = input()

    if s == "1":

        #строим графики
        x = np.linspace(-6, 6, 50) 
        fig = plt.figure(figsize = (14, 8))
         
        y = np.sin((math.pi / 3) + x)
        plt.plot(x, y, 'b', label ='sin(pi / 3 + x)')

        n1 = (3 ** 0.5) / 2
        
        #1
        y1 = n1 + ((1 / 2) * x)
        plt.plot(x, y1, 'r:', label ='1')
         
        #2
        y2 = n1 + ((1 / 2) * x) + (((-(3 ** 0.5) / 2) * (x**2)) / 2)
        plt.plot(x, y2, 'y:', label ='2')

        #3
        y3 = n1 + ((1 / 2) * x) + (((-(3 ** 0.5) / 2) * (x**2)) / 2) + \
             (((-(1 / 2)) * (x**3)) / (2 * 3))
        plt.plot(x, y3, 'm:', label ='3')
         
        #4
        y4 = n1 + ((1 / 2) * x) + (((-(3 ** 0.5) / 2) * (x**2)) / 2) + \
             (((-(1 / 2)) * (x**3)) / (2 * 3)) + \
             ((((3 ** 0.5) / 2) * (x ** 4)) / (2 * 3 * 4))
        plt.plot(x, y4, 'k:', label ='4')

        #5
        y5 = n1 + ((1 / 2) * x) + (((-(3 ** 0.5) / 2) * (x**2)) / 2) + \
             (((-(1 / 2)) * (x**3)) / (2 * 3)) + \
             ((((3 ** 0.5) / 2) * (x ** 4)) / (2 * 3 * 4)) + \
             (((1/2) * (x ** 5)) / (2 * 3 * 4 * 5))             
        plt.plot(x, y5, 'g:', label ='5')

        #6
        y6 = n1 + ((1 / 2) * x) + (((-(3 ** 0.5) / 2) * (x**2)) / 2) + \
             (((-(1 / 2)) * (x**3)) / (2 * 3)) + \
             ((((3 ** 0.5) / 2) * (x ** 4)) / (2 * 3 * 4)) + \
             (((1/2) * (x ** 5)) / (2 * 3 * 4 * 5)) + \
             (((-(3 ** 0.5) / 2) * (x ** 6)) / (2 * 3 * 4 * 5 * 6))
        plt.plot(x, y6, 'c:', label ='6')

        #7
        y7 = n1 + ((1 / 2) * x) + (((-(3 ** 0.5) / 2) * (x**2)) / 2) + \
             (((-(1 / 2)) * (x**3)) / (2 * 3)) + \
             ((((3 ** 0.5) / 2) * (x ** 4)) / (2 * 3 * 4)) + \
             (((1/2) * (x ** 5)) / (2 * 3 * 4 * 5)) + \
             (((-(3 ** 0.5) / 2) * (x ** 6)) / (2 * 3 * 4 * 5 * 6)) + \
             ((((-(1/2)) * (x ** 7)) / (2 * 3 * 4 * 5 * 6 * 7)))
        plt.plot(x, y7, 'm:', label ='7')
         

        # фичи для улучшения просматриваемости графиков
        plt.legend()
        plt.grid(True, linestyle =':')
        plt.xlim([-6, 6])
        plt.ylim([-4, 4])
         
        plt.title('f(x) = sin (pi / 3 + x)')
        plt.xlabel('x-axis')
        plt.ylabel('y-axis')
         
        # Show plot
        plt.show()

    elif s == "2":
        # далее МТ - многочлен Тейлора
        
        # в аналитическом методе мы посчитали, что:
        # МТ порядка n1 = sqrt(3)/2 + (1/2)*x - (sqrt(3)/2)*x^2/2! - (1/2)*x^3/3! + d1
        # МТ порядка n2 = sqrt(3)/2 + (1/2)*x - (sqrt(3)/2)*x^2/2! - (1/2)*x^3/3! +
        #                 + (sqrt(3)/2)*x^4/4! + (1/2)*x^5/5! - (sqrt(3)/2)*x^6/6! -
        #                 - (1/2)*x^7/7!

        # известно по условию
        a = 0.2
        d1 = 10 ** (-3)
        d2 = 10 ** (-6)

        # вычисляем приближенные значения:
        # а -> МТ порядка n1
        # а -> МТ порядка n2

        res_1 = (3 ** 0.5)/2 + (1/2)*0.2 - ((((3 ** 0.5)/2)*(0.2 ** 2))/2) - (((1/2)*(0.2 ** 3))/(2 * 3)) + d1
        res_2 = (3 ** 0.5)/2 + (1/2)*0.2 - ((((3 ** 0.5)/2)*(0.2 ** 2))/2) - (((1/2)*(0.2 ** 3))/(2 * 3)) + \
                ((((3 ** 0.5)/2)*(0.2 ** 4))/(2 * 3 * 4)) + (((1/2)*(0.2 ** 5))/(2 * 3 * 4 * 5)) - \
                - ((((3 ** 0.5)/2)*(0.2 ** 6))/(2 * 3 * 4 * 5 * 6)) - (((1/2)*(0.2 ** 7))/(2 * 3 * 4 * 5 * 6 * 7)) + d2

        print ("Приближенное значение f(a), полученное при замене функции f",
               "многочленом Тейлора порядка n1", "=", res_1)
        print ()
        
        print ("Приближенное значение f(a), полученное при замене функции f",
               "многочленом Тейлора порядка n2", "=", res_2)


    elif s == "3":

        a = 0.2
        d1 = 10 ** (-3)
        d2 = 10 ** (-6)

        # приближенные значения
        res_1 = (3 ** 0.5)/2 + (1/2)*0.2 - (((3 ** 0.5)/2)*(0.2 ** 2))/2 - ((1/2)*(0.2 ** 3))/(2 * 3) + d1
        res_2 = (3 ** 0.5)/2 + (1/2)*0.2 - ((((3 ** 0.5)/2)*(0.2 ** 2))/2) - (((1/2)*(0.2 ** 3))/(2 * 3)) + \
                ((((3 ** 0.5)/2)*(0.2 ** 4))/(2 * 3 * 4)) + (((1/2)*(0.2 ** 5))/(2 * 3 * 4 * 5)) - \
                - ((((3 ** 0.5)/2)*(0.2 ** 6))/(2 * 3 * 4 * 5 * 6)) - (((1/2)*(0.2 ** 7))/(2 * 3 * 4 * 5 * 6 * 7)) + d2


        # точное значение
        tz = (math.sin (math.pi/3 + 0.2))
        
        print ("Точное значение", tz)
        print ()

        print ("Приближенное значение f(a), полученное при замене функции f",
               "многочленом Тейлора порядка n1", "=", res_1)
        print ()

        print ("Приближенное значение f(a), полученное при замене функции f",
               "многочленом Тейлора порядка n2", "=", res_2)
        print ()      
        
        print ("Разность точного значения и приближенного значения, полученного при замене функции f",
               "многочленом Тейлора порядка n1", "=", abs(tz - res_1))
        print ()
        
        print ("Разность точного значения и приближенного значения, полученного при замене функции f",
               "многочленом Тейлора порядка n2", "=", abs(tz - res_2))
        print ()
        
        print ("Из полученных значений убеждаемся, что требуемая точность достигнута.")
        
    else:
        if s != "0":
            print ("Вы ввели неправильный номер задания.")

